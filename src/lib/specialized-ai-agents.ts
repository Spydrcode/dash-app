// Specialized AI Agents for Performance Breakdown and Time Analysis
// Connected to Local Ollama Models

export class PerformanceBreakdownAgent {
  private baseUrl = 'http://localhost:11434';
  private model = 'llama3.1:latest'; // Using Llama3.1 for data processing

  async analyzePerformance(trips: any[], summary: any): Promise<any> {
    try {
      console.log('üìä Performance Breakdown Agent analyzing data with Ollama...');
      
      const prompt = `As a rideshare performance analyst, analyze this driving data and provide detailed performance breakdown insights:

TRIP DATA SUMMARY:
- Total trips: ${summary.total_trips}
- Total earnings: $${summary.total_earnings}
- Total profit: $${summary.total_profit}
- Total distance: ${summary.total_distance} miles
- Performance score: ${summary.performance_score}/100

DATA QUALITY NOTES:
- This dataset has been processed and cleaned
- Some trips may have had missing earnings data that was estimated
- High-volume operation with realistic validation applied

INDIVIDUAL TRIP ANALYSIS:
${trips.slice(0, 10).map((trip, i) => {
  const earnings = trip.trip_data?.driver_earnings || trip.driver_earnings || 0;
  const distance = trip.trip_data?.distance || trip.distance || 0;
  const profit = trip.trip_data?.profit || trip.profit || 0;
  const estimated = trip.estimated_earnings || trip.trip_data?.estimated_earnings ? ' (estimated)' : '';
  return `Trip ${i+1}: $${earnings}${estimated} earned, ${distance} miles, $${profit} profit`;
}).join('\n')}

Provide detailed analysis in JSON format:
{
  "earnings_per_mile": <calculated value>,
  "profit_per_mile": <calculated value>,
  "average_trip_profit": <calculated value>,
  "fuel_cost_ratio": <calculated value>,
  "efficiency_insights": ["insight1", "insight2"],
  "optimization_recommendations": ["rec1", "rec2"],
  "performance_trends": "analysis of patterns",
  "cost_analysis": "detailed cost breakdown",
  "data_quality_notes": "assessment of data reliability"
}`;

      const response = await fetch(`${this.baseUrl}/api/generate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          model: this.model,
          prompt,
          stream: false,
          options: {
            temperature: 0.1,
            top_p: 0.9,
            num_predict: 400
          }
        })
      });

      if (!response.ok) {
        throw new Error(`Ollama API error: ${response.status}`);
      }

      const result = await response.json();
      console.log('‚úÖ Performance Breakdown Agent completed analysis');
      
      return this.parsePerformanceResponse(result.response, summary);
    } catch (error) {
      console.error('‚ùå Performance Breakdown Agent failed:', error);
      return this.generateFallbackPerformance(summary);
    }
  }

  private parsePerformanceResponse(response: string, summary: any): any {
    try {
      // Try to extract JSON from response
      const jsonMatch = response.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        const parsed = JSON.parse(jsonMatch[0]);
        
        // Ensure we have required fields with calculated fallbacks
        return {
          earnings_per_mile: parsed.earnings_per_mile || (summary.total_earnings / summary.total_distance),
          profit_per_mile: parsed.profit_per_mile || (summary.total_profit / summary.total_distance),
          average_trip_profit: parsed.average_trip_profit || (summary.total_profit / summary.total_trips),
          fuel_cost_ratio: parsed.fuel_cost_ratio || 0.15,
          efficiency_insights: parsed.efficiency_insights || ['Analysis generated by AI agent'],
          optimization_recommendations: parsed.optimization_recommendations || ['Recommendations from AI agent'],
          performance_trends: parsed.performance_trends || 'Trends analyzed by AI',
          cost_analysis: parsed.cost_analysis || 'Cost breakdown from AI analysis',
          ai_generated: true,
          agent: 'Performance Breakdown Agent (Llama3.1)'
        };
      }
    } catch (parseError) {
      console.warn('‚ö†Ô∏è Could not parse AI response, using calculations');
    }
    
    return this.generateFallbackPerformance(summary);
  }

  private generateFallbackPerformance(summary: any): any {
    return {
      earnings_per_mile: summary.total_distance > 0 ? summary.total_earnings / summary.total_distance : 0,
      profit_per_mile: summary.total_distance > 0 ? summary.total_profit / summary.total_distance : 0,
      average_trip_profit: summary.total_trips > 0 ? summary.total_profit / summary.total_trips : 0,
      fuel_cost_ratio: 0.15,
      efficiency_insights: ['Calculated performance metrics'],
      optimization_recommendations: ['Consider optimizing routes for better efficiency'],
      performance_trends: 'Basic calculation without AI analysis',
      cost_analysis: 'Fuel costs estimated at 15% of earnings',
      ai_generated: false,
      agent: 'Fallback calculations'
    };
  }
}

export class TimeAnalysisAgent {
  private baseUrl = 'http://localhost:11434';
  private model = 'llama3.1:latest'; // Using Llama3.1 for pattern analysis

  async analyzeTimePatterns(trips: any[]): Promise<any> {
    try {
      console.log('‚è∞ Time Analysis Agent analyzing patterns with Ollama...');

      // Organize trips by day and time
      const timeData = this.organizeTimeData(trips);
      
      const prompt = `As a rideshare time pattern analyst, analyze this temporal driving data and identify optimal times and days:

TIME PATTERN DATA:
Day breakdown:
${Object.entries(timeData.dayGroups).map(([day, dayTrips]) => 
  `${day}: ${dayTrips.length} trips, $${dayTrips.reduce((sum: number, trip: any) => sum + (trip.trip_data?.profit || 0), 0).toFixed(2)} profit`
).join('\n')}

Hour breakdown (top 5 hours):
${Object.entries(timeData.hourGroups)
  .map(([hour, hourTrips]) => ({ hour, trips: hourTrips.length, profit: hourTrips.reduce((sum: number, trip: any) => sum + (trip.trip_data?.profit || 0), 0) }))
  .filter((h: any) => h.trips > 0)
  .sort((a: any, b: any) => b.profit - a.profit)
  .slice(0, 5)
  .map((h: any) => `Hour ${h.hour}: ${h.trips} trips, $${h.profit.toFixed(2)} profit`)
  .join('\n')}

Provide detailed time analysis in JSON format:
{
  "best_day": {
    "day": "day_name",
    "profit": <value>,
    "trips": <count>,
    "reasons": ["why this day is best"]
  },
  "best_hour": {
    "hour": "hour_value",
    "profit": <value>,
    "trips": <count>,
    "reasons": ["why this hour is optimal"]
  },
  "patterns_identified": ["pattern1", "pattern2"],
  "scheduling_recommendations": ["rec1", "rec2"],
  "peak_performance_times": "analysis",
  "optimization_strategy": "strategy for better timing"
}`;

      const response = await fetch(`${this.baseUrl}/api/generate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          model: this.model,
          prompt,
          stream: false,
          options: {
            temperature: 0.2,
            top_p: 0.9,
            num_predict: 350
          }
        })
      });

      if (!response.ok) {
        throw new Error(`Ollama API error: ${response.status}`);
      }

      const result = await response.json();
      console.log('‚úÖ Time Analysis Agent completed analysis');
      
      return this.parseTimeResponse(result.response, timeData);
    } catch (error) {
      console.error('‚ùå Time Analysis Agent failed:', error);
      return this.generateFallbackTimeAnalysis(trips);
    }
  }

  private organizeTimeData(trips: any[]) {
    const dayGroups: Record<string, any[]> = {
      Sunday: [], Monday: [], Tuesday: [], Wednesday: [], Thursday: [], Friday: [], Saturday: []
    };

    const hourGroups: Record<string, any[]> = {};
    for (let i = 0; i < 24; i++) {
      hourGroups[i.toString()] = [];
    }

    trips.forEach(trip => {
      const tripDate = new Date(trip.trip_data?.trip_date || trip.created_at);
      const dayName = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][tripDate.getDay()];
      dayGroups[dayName].push(trip);

      if (trip.trip_data?.trip_time || trip.trip_time) {
        const tripTime = trip.trip_data?.trip_time || trip.trip_time;
        const hour = parseInt(tripTime.split(':')[0]) || 12;
        hourGroups[hour.toString()].push(trip);
      }
    });

    return { dayGroups, hourGroups };
  }

  private parseTimeResponse(response: string, timeData: any): any {
    try {
      // Try to extract JSON from response
      const jsonMatch = response.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        const parsed = JSON.parse(jsonMatch[0]);
        
        // Validate and enhance with calculated data
        const bestDay = this.findBestDay(timeData.dayGroups);
        const bestHour = this.findBestHour(timeData.hourGroups);

        return {
          best_day: parsed.best_day || bestDay,
          best_hour: parsed.best_hour || bestHour,
          patterns_identified: parsed.patterns_identified || ['AI-identified patterns'],
          scheduling_recommendations: parsed.scheduling_recommendations || ['Optimize schedule based on patterns'],
          peak_performance_times: parsed.peak_performance_times || 'Peak times analysis by AI',
          optimization_strategy: parsed.optimization_strategy || 'Schedule optimization strategy',
          ai_generated: true,
          agent: 'Time Analysis Agent (Llama3.1)'
        };
      }
    } catch (parseError) {
      console.warn('‚ö†Ô∏è Could not parse AI response, using calculations');
    }
    
    return this.generateFallbackTimeAnalysis(Object.values(timeData.dayGroups).flat());
  }

  private findBestDay(dayGroups: Record<string, any[]>) {
    return Object.entries(dayGroups)
      .map(([day, dayTrips]) => ({
        day,
        profit: dayTrips.reduce((sum, trip) => sum + (trip.trip_data?.profit || 0), 0),
        trips: dayTrips.length
      }))
      .sort((a, b) => b.profit - a.profit)[0];
  }

  private findBestHour(hourGroups: Record<string, any[]>) {
    return Object.entries(hourGroups)
      .map(([hour, hourTrips]) => ({
        hour,
        profit: hourTrips.reduce((sum, trip) => sum + (trip.trip_data?.profit || 0), 0),
        trips: hourTrips.length
      }))
      .filter(h => h.trips > 0)
      .sort((a, b) => b.profit - a.profit)[0];
  }

  private generateFallbackTimeAnalysis(trips: any[]): any {
    const timeData = this.organizeTimeData(trips);
    const bestDay = this.findBestDay(timeData.dayGroups);
    const bestHour = this.findBestHour(timeData.hourGroups);

    return {
      best_day: bestDay,
      best_hour: bestHour,
      patterns_identified: ['Basic time pattern calculation'],
      scheduling_recommendations: ['Consider working during peak hours'],
      peak_performance_times: 'Calculated based on historical data',
      optimization_strategy: 'Focus on high-profit time periods',
      ai_generated: false,
      agent: 'Fallback calculations'
    };
  }
}

// Main coordinator that uses specialized agents
export class SpecializedAICoordinator {
  private performanceAgent = new PerformanceBreakdownAgent();
  private timeAgent = new TimeAnalysisAgent();

  async generateEnhancedInsights(trips: any[], summary: any) {
    console.log('ü§ñ Specialized AI Coordinator starting analysis...');
    
    const [performanceBreakdown, timeAnalysis] = await Promise.all([
      this.performanceAgent.analyzePerformance(trips, summary),
      this.timeAgent.analyzeTimePatterns(trips)
    ]);

    console.log('‚úÖ Specialized AI Coordinator completed analysis');
    
    return {
      performance_breakdown: performanceBreakdown,
      time_analysis: timeAnalysis,
      ai_enhanced: true,
      generated_by: 'Specialized AI Agents (Ollama)'
    };
  }
}